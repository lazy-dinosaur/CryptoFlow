//@version=5
indicator("Channel Bounce Alerts", overlay=true)

// ===== INPUTS =====
confirmCandles = input.int(3, "Confirm Candles", minval=1, maxval=10)
minTouches = input.int(2, "Min Touches for Channel", minval=1, maxval=10)
channelTolerance = input.float(0.4, "Channel Tolerance %", minval=0.1, maxval=2.0, step=0.1)
touchThreshold = input.float(0.3, "Touch Threshold %", minval=0.1, maxval=1.0, step=0.1)
slBufferPct = input.float(0.08, "SL Buffer %", minval=0.01, maxval=0.5, step=0.01)

// ===== SWING POINT DETECTION =====
var float potentialHighPrice = high
var int potentialHighIdx = 0
var int candlesSinceHigh = 0

var float potentialLowPrice = low
var int potentialLowIdx = 0
var int candlesSinceLow = 0

var float[] swingHighs = array.new_float(0)
var int[] swingHighBars = array.new_int(0)
var float[] swingLows = array.new_float(0)
var int[] swingLowBars = array.new_int(0)

// Update potential high
if high > potentialHighPrice
    potentialHighPrice := high
    potentialHighIdx := bar_index
    candlesSinceHigh := 0
else
    candlesSinceHigh += 1
    if candlesSinceHigh == confirmCandles
        array.push(swingHighs, potentialHighPrice)
        array.push(swingHighBars, potentialHighIdx)
        potentialHighPrice := high
        potentialHighIdx := bar_index
        candlesSinceHigh := 0

// Update potential low
if low < potentialLowPrice
    potentialLowPrice := low
    potentialLowIdx := bar_index
    candlesSinceLow := 0
else
    candlesSinceLow += 1
    if candlesSinceLow == confirmCandles
        array.push(swingLows, potentialLowPrice)
        array.push(swingLowBars, potentialLowIdx)
        potentialLowPrice := low
        potentialLowIdx := bar_index
        candlesSinceLow := 0

// Keep only recent swings
if array.size(swingHighs) > 50
    array.shift(swingHighs)
    array.shift(swingHighBars)
if array.size(swingLows) > 50
    array.shift(swingLows)
    array.shift(swingLowBars)

// ===== CHANNEL DETECTION =====
var float channelSupport = na
var float channelResistance = na
var int supportTouches = 0
var int resistanceTouches = 0

detectChannel() =>
    float bestSupport = na
    float bestResistance = na
    int bestSupportTouches = 0
    int bestResistanceTouches = 0

    if array.size(swingLows) >= minTouches and array.size(swingHighs) >= minTouches
        for i = 0 to math.min(array.size(swingLows) - 1, 19)
            float level = array.get(swingLows, array.size(swingLows) - 1 - i)
            int touches = 0
            for j = 0 to math.min(array.size(swingLows) - 1, 19)
                float otherLevel = array.get(swingLows, array.size(swingLows) - 1 - j)
                if math.abs(otherLevel - level) / level * 100 < channelTolerance
                    touches += 1
            if touches >= minTouches and touches > bestSupportTouches
                bestSupportTouches := touches
                bestSupport := level

        for i = 0 to math.min(array.size(swingHighs) - 1, 19)
            float level = array.get(swingHighs, array.size(swingHighs) - 1 - i)
            int touches = 0
            for j = 0 to math.min(array.size(swingHighs) - 1, 19)
                float otherLevel = array.get(swingHighs, array.size(swingHighs) - 1 - j)
                if math.abs(otherLevel - level) / level * 100 < channelTolerance
                    touches += 1
            if touches >= minTouches and touches > bestResistanceTouches
                bestResistanceTouches := touches
                bestResistance := level

    [bestSupport, bestResistance, bestSupportTouches, bestResistanceTouches]

[newSupport, newResistance, sTouches, rTouches] = detectChannel()

if not na(newSupport) and not na(newResistance) and newResistance > newSupport
    float width = (newResistance - newSupport) / newSupport * 100
    if width >= 0.5 and width <= 3.0
        channelSupport := newSupport
        channelResistance := newResistance
        supportTouches := sTouches
        resistanceTouches := rTouches

// ===== SIGNAL CONDITIONS =====
float mid = (channelSupport + channelResistance) / 2
bool validChannel = not na(channelSupport) and not na(channelResistance)

// Support bounce (LONG)
float supportTouchZone = channelSupport * (1 + touchThreshold / 100)
bool longSignal = validChannel and low <= supportTouchZone and close > channelSupport

// Resistance bounce (SHORT)
float resistanceTouchZone = channelResistance * (1 - touchThreshold / 100)
bool shortSignal = validChannel and high >= resistanceTouchZone and close < channelResistance

// Calculate levels for alerts
float longSL = channelSupport * (1 - slBufferPct / 100)
float longTP = mid
float shortSL = channelResistance * (1 + slBufferPct / 100)
float shortTP = mid

// ===== ALERTS =====
alertcondition(longSignal, title="LONG Signal", message="LONG @ {{close}} | SL: " + str.tostring(longSL) + " | TP: " + str.tostring(longTP))
alertcondition(shortSignal, title="SHORT Signal", message="SHORT @ {{close}} | SL: " + str.tostring(shortSL) + " | TP: " + str.tostring(shortTP))

// ===== PLOTTING =====
// Channel lines
p1 = plot(validChannel ? channelSupport : na, "Support", color=color.new(color.green, 20), linewidth=2, style=plot.style_stepline)
p2 = plot(validChannel ? channelResistance : na, "Resistance", color=color.new(color.red, 20), linewidth=2, style=plot.style_stepline)
plot(validChannel ? mid : na, "Mid (TP)", color=color.new(color.orange, 40), linewidth=1, style=plot.style_stepline)

// Fill channel
fill(p1, p2, color=color.new(color.blue, 92))

// Signal markers
plotshape(longSignal, "LONG", shape.triangleup, location.belowbar, color.green, size=size.normal)
plotshape(shortSignal, "SHORT", shape.triangledown, location.abovebar, color.red, size=size.normal)

// SL/TP lines on signal
plot(longSignal ? longSL : na, "Long SL", color=color.red, linewidth=1, style=plot.style_cross)
plot(longSignal ? longTP : na, "Long TP", color=color.green, linewidth=1, style=plot.style_cross)
plot(shortSignal ? shortSL : na, "Short SL", color=color.red, linewidth=1, style=plot.style_cross)
plot(shortSignal ? shortTP : na, "Short TP", color=color.green, linewidth=1, style=plot.style_cross)

// Info table
var table infoTable = table.new(position.top_right, 2, 6, bgcolor=color.new(color.black, 80), border_width=1)
if barstate.islast
    if validChannel
        table.cell(infoTable, 0, 0, "CHANNEL", text_color=color.white, text_size=size.small)
        table.cell(infoTable, 1, 0, "ACTIVE", text_color=color.lime, text_size=size.small)
        table.cell(infoTable, 0, 1, "Support", text_color=color.white, text_size=size.small)
        table.cell(infoTable, 1, 1, str.tostring(channelSupport, "#.#"), text_color=color.green, text_size=size.small)
        table.cell(infoTable, 0, 2, "Resistance", text_color=color.white, text_size=size.small)
        table.cell(infoTable, 1, 2, str.tostring(channelResistance, "#.#"), text_color=color.red, text_size=size.small)
        table.cell(infoTable, 0, 3, "TP (Mid)", text_color=color.white, text_size=size.small)
        table.cell(infoTable, 1, 3, str.tostring(mid, "#.#"), text_color=color.orange, text_size=size.small)
        table.cell(infoTable, 0, 4, "Width", text_color=color.white, text_size=size.small)
        table.cell(infoTable, 1, 4, str.tostring((channelResistance - channelSupport) / channelSupport * 100, "#.##") + "%", text_color=color.white, text_size=size.small)
        table.cell(infoTable, 0, 5, "Touches", text_color=color.white, text_size=size.small)
        table.cell(infoTable, 1, 5, "S:" + str.tostring(supportTouches) + " R:" + str.tostring(resistanceTouches), text_color=color.white, text_size=size.small)
    else
        table.cell(infoTable, 0, 0, "CHANNEL", text_color=color.white, text_size=size.small)
        table.cell(infoTable, 1, 0, "NONE", text_color=color.gray, text_size=size.small)
