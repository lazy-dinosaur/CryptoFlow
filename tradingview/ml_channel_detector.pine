// ML Channel Detector - Original Logic
//@version=5
indicator("ML Channel Detector", overlay=true, max_lines_count=500, max_labels_count=500)

// === INPUTS ===
confirm_candles = input.int(3, "Confirm Candles", minval=1, maxval=10)
touch_tolerance = input.float(0.4, "Touch Tolerance %", minval=0.1, maxval=2.0, step=0.1) / 100
min_channel_width = input.float(0.8, "Min Channel Width %", minval=0.1, maxval=5.0, step=0.1) / 100
max_channel_width = input.float(5.0, "Max Channel Width %", minval=1.0, maxval=10.0, step=0.1) / 100
min_touches = input.int(2, "Min Touches for Confirm", minval=1, maxval=5)
lookback = input.int(100, "Lookback Bars", minval=20, maxval=500)

// === COLORS ===
color_support = input.color(color.green, "Support Color")
color_resistance = input.color(color.red, "Resistance Color")
color_swing_high = input.color(color.red, "Swing High Marker")
color_swing_low = input.color(color.green, "Swing Low Marker")
show_swing_markers = input.bool(true, "Show Swing Markers")

// === SWING POINT DETECTION ===
var float potential_high_price = high
var int potential_high_idx = bar_index
var int candles_since_high = 0

var float potential_low_price = low
var int potential_low_idx = bar_index
var int candles_since_low = 0

var float[] swing_high_prices = array.new_float()
var int[] swing_high_indices = array.new_int()
var float[] swing_low_prices = array.new_float()
var int[] swing_low_indices = array.new_int()

// Detect swing highs
if high > potential_high_price
    potential_high_idx := bar_index
    potential_high_price := high
    candles_since_high := 0
else
    candles_since_high := candles_since_high + 1
    if candles_since_high == confirm_candles
        array.push(swing_high_prices, potential_high_price)
        array.push(swing_high_indices, potential_high_idx)
        if show_swing_markers
            label.new(potential_high_idx, potential_high_price, "H", color=color.new(color_swing_high, 70), style=label.style_label_down, textcolor=color_swing_high, size=size.tiny)

if candles_since_high >= confirm_candles
    potential_high_price := high
    potential_high_idx := bar_index
    candles_since_high := 0

// Detect swing lows
if low < potential_low_price
    potential_low_idx := bar_index
    potential_low_price := low
    candles_since_low := 0
else
    candles_since_low := candles_since_low + 1
    if candles_since_low == confirm_candles
        array.push(swing_low_prices, potential_low_price)
        array.push(swing_low_indices, potential_low_idx)
        if show_swing_markers
            label.new(potential_low_idx, potential_low_price, "L", color=color.new(color_swing_low, 70), style=label.style_label_up, textcolor=color_swing_low, size=size.tiny)

if candles_since_low >= confirm_candles
    potential_low_price := low
    potential_low_idx := bar_index
    candles_since_low := 0

// === CHANNEL DETECTION ===
var line support_line = na
var line resistance_line = na
var label channel_label = na

// Count touches within tolerance
count_support_touches(price) =>
    cnt = 0
    arr_len = array.size(swing_low_prices)
    for i = math.max(0, arr_len - lookback) to arr_len - 1
        p = array.get(swing_low_prices, i)
        if math.abs(p - price) / price < touch_tolerance
            cnt := cnt + 1
    cnt

count_resistance_touches(price) =>
    cnt = 0
    arr_len = array.size(swing_high_prices)
    for i = math.max(0, arr_len - lookback) to arr_len - 1
        p = array.get(swing_high_prices, i)
        if math.abs(p - price) / price < touch_tolerance
            cnt := cnt + 1
    cnt

// Find best channel
var float best_support = na
var float best_resistance = na
var int best_score = 0

if barstate.islast
    if not na(support_line)
        line.delete(support_line)
    if not na(resistance_line)
        line.delete(resistance_line)
    if not na(channel_label)
        label.delete(channel_label)

    best_score := 0
    best_support := na
    best_resistance := na

    high_size = array.size(swing_high_prices)
    low_size = array.size(swing_low_prices)

    if high_size > 0 and low_size > 0
        for hi = math.max(0, high_size - 30) to high_size - 1
            r_price = array.get(swing_high_prices, hi)
            r_idx = array.get(swing_high_indices, hi)
            if bar_index - r_idx > 100
                continue
            for li = math.max(0, low_size - 30) to low_size - 1
                s_price = array.get(swing_low_prices, li)
                s_idx = array.get(swing_low_indices, li)
                if bar_index - s_idx > 100
                    continue
                if r_price > s_price
                    width_pct = (r_price - s_price) / s_price
                    if width_pct >= min_channel_width and width_pct <= max_channel_width
                        if close >= s_price * 0.98 and close <= r_price * 1.02
                            s_touches = count_support_touches(s_price)
                            r_touches = count_resistance_touches(r_price)
                            if s_touches >= min_touches and r_touches >= min_touches
                                score = s_touches + r_touches
                                if score > best_score
                                    best_score := score
                                    best_support := s_price
                                    best_resistance := r_price

    if not na(best_support) and not na(best_resistance)
        s_touches = count_support_touches(best_support)
        r_touches = count_resistance_touches(best_resistance)
        width_pct = (best_resistance - best_support) / best_support * 100

        support_line := line.new(bar_index - lookback, best_support, bar_index, best_support, color=color_support, width=2, style=line.style_dashed)
        resistance_line := line.new(bar_index - lookback, best_resistance, bar_index, best_resistance, color=color_resistance, width=2, style=line.style_dashed)

        channel_label := label.new(bar_index, best_resistance, "S:" + str.tostring(best_support, "#.0") + "(" + str.tostring(s_touches) + ") R:" + str.tostring(best_resistance, "#.0") + "(" + str.tostring(r_touches) + ") W:" + str.tostring(width_pct, "#.#") + "%", color=color.new(color.blue, 80), textcolor=color.white, style=label.style_label_left)

// === INFO TABLE ===
var table info_table = table.new(position.top_right, 2, 6, bgcolor=color.new(color.black, 80))

if barstate.islast
    table.cell(info_table, 0, 0, "ML Channel", text_color=color.white, text_size=size.small)
    table.cell(info_table, 1, 0, "Detector", text_color=color.white, text_size=size.small)
    table.cell(info_table, 0, 1, "Confirm", text_color=color.gray, text_size=size.tiny)
    table.cell(info_table, 1, 1, str.tostring(confirm_candles) + " bars", text_color=color.white, text_size=size.tiny)
    table.cell(info_table, 0, 2, "Tolerance", text_color=color.gray, text_size=size.tiny)
    table.cell(info_table, 1, 2, str.tostring(touch_tolerance * 100, "#.#") + "%", text_color=color.white, text_size=size.tiny)
    table.cell(info_table, 0, 3, "Swing H", text_color=color.gray, text_size=size.tiny)
    table.cell(info_table, 1, 3, str.tostring(array.size(swing_high_prices)), text_color=color_swing_high, text_size=size.tiny)
    table.cell(info_table, 0, 4, "Swing L", text_color=color.gray, text_size=size.tiny)
    table.cell(info_table, 1, 4, str.tostring(array.size(swing_low_prices)), text_color=color_swing_low, text_size=size.tiny)
    table.cell(info_table, 0, 5, "Channel", text_color=color.gray, text_size=size.tiny)
    if not na(best_support)
        table.cell(info_table, 1, 5, "FOUND", text_color=color.green, text_size=size.tiny)
    else
        table.cell(info_table, 1, 5, "NONE", text_color=color.red, text_size=size.tiny)
