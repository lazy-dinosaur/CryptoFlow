"""
Base Strategy Class for Backtesting
"""

from abc import ABC, abstractmethod
from dataclasses import dataclass
from enum import Enum
from typing import Optional, Dict, Any
import pandas as pd


class SignalType(Enum):
    LONG = "LONG"
    SHORT = "SHORT"
    CLOSE = "CLOSE"
    NONE = "NONE"


@dataclass
class Signal:
    """Trading signal generated by strategy."""
    type: SignalType
    entry_price: float = 0.0
    stop_loss: float = 0.0
    take_profit: float = 0.0
    confidence: float = 0.0
    reason: str = ""


@dataclass
class Position:
    """Current position state."""
    type: Optional[SignalType] = None  # LONG or SHORT
    entry_price: float = 0.0
    entry_time: pd.Timestamp = None
    stop_loss: float = 0.0
    take_profit: float = 0.0
    size: float = 1.0


class Strategy(ABC):
    """Abstract base class for trading strategies."""

    def __init__(self, params: Dict[str, Any] = None):
        self.params = params or {}
        self.position: Optional[Position] = None
        self.history = []  # Store historical data for indicators

    @property
    @abstractmethod
    def name(self) -> str:
        """Strategy name."""
        pass

    @abstractmethod
    def on_candle(self, candle: pd.Series, history: pd.DataFrame) -> Signal:
        """
        Called for each new candle.

        Args:
            candle: Current candle data (open, high, low, close, volume, delta, etc.)
            history: Historical candles up to current point

        Returns:
            Signal indicating action to take
        """
        pass

    def check_exit(self, candle: pd.Series) -> Optional[Signal]:
        """Check if current position should be closed based on SL/TP."""
        if self.position is None:
            return None

        current_price = candle['close']

        if self.position.type == SignalType.LONG:
            # Check stop loss
            if current_price <= self.position.stop_loss:
                return Signal(SignalType.CLOSE, reason="Stop Loss Hit")
            # Check take profit
            if current_price >= self.position.take_profit:
                return Signal(SignalType.CLOSE, reason="Take Profit Hit")

        elif self.position.type == SignalType.SHORT:
            # Check stop loss
            if current_price >= self.position.stop_loss:
                return Signal(SignalType.CLOSE, reason="Stop Loss Hit")
            # Check take profit
            if current_price <= self.position.take_profit:
                return Signal(SignalType.CLOSE, reason="Take Profit Hit")

        return None

    def enter_position(self, signal: Signal, candle: pd.Series):
        """Enter a new position."""
        self.position = Position(
            type=signal.type,
            entry_price=signal.entry_price or candle['close'],
            entry_time=candle.name,
            stop_loss=signal.stop_loss,
            take_profit=signal.take_profit
        )

    def exit_position(self):
        """Exit current position."""
        self.position = None

    def has_position(self) -> bool:
        """Check if currently in a position."""
        return self.position is not None
